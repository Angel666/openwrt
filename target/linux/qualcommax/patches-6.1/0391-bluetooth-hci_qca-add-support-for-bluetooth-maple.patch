--- a/drivers/bluetooth/btqca.c
+++ b/drivers/bluetooth/btqca.c
@@ -300,6 +300,9 @@ static void qca_tlv_check_data(struct hc
 		BT_DBG("TLV Type\t\t : 0x%x", type_len & 0x000000ff);
 		BT_DBG("Length\t\t : %d bytes", length);
 
+		if (qca_is_maple(soc_type))
+			break;
+
 		idx = 0;
 		data = tlv->data;
 		while (idx < length) {
@@ -603,6 +606,9 @@ int qca_uart_setup(struct hci_dev *hdev,
 		qca_send_patch_config_cmd(hdev);
 
 	/* Download rampatch file */
+	if (qca_is_maple(soc_type))
+		goto download_nvm;
+
 	config.type = TLV_TYPE_PATCH;
 	switch (soc_type) {
 	case QCA_WCN3990:
@@ -649,6 +655,7 @@ int qca_uart_setup(struct hci_dev *hdev,
 	/* Give the controller some time to get ready to receive the NVM */
 	msleep(10);
 
+download_nvm:
 	/* Download NVM configuration */
 	config.type = TLV_TYPE_NVM;
 	if (firmware_name) {
@@ -675,6 +682,9 @@ int qca_uart_setup(struct hci_dev *hdev,
 			snprintf(config.fwname, sizeof(config.fwname),
 				 "qca/htnv%02x.bin", rom_ver);
 			break;
+		case QCA_MAPLE:
+			snprintf(config.fwname, sizeof(config.fwname),
+				"qca/mpnv%02x.bin", rom_ver);
 		case QCA_WCN6750:
 			snprintf(config.fwname, sizeof(config.fwname),
 				 "qca/msnv%02x.bin", rom_ver);
@@ -693,6 +703,8 @@ int qca_uart_setup(struct hci_dev *hdev,
 				 "qca/nvm_%08x.bin", soc_ver);
 		}
 	}
+	if (qca_is_maple(soc_type))
+		msleep(MAPLE_NVM_READY_DELAY_MS);
 
 	err = qca_download_firmware(hdev, &config, soc_type, rom_ver);
 	if (err < 0) {
@@ -700,6 +712,9 @@ int qca_uart_setup(struct hci_dev *hdev,
 		return err;
 	}
 
+	if (qca_is_maple(soc_type))
+		msleep(MAPLE_NVM_READY_DELAY_MS);
+
 	switch (soc_type) {
 	case QCA_WCN3991:
 	case QCA_QCA6390:
@@ -741,6 +756,7 @@ int qca_uart_setup(struct hci_dev *hdev,
 	case QCA_WCN6750:
 	case QCA_WCN6855:
 	case QCA_WCN7850:
+	case QCA_MAPLE:
 		/* get fw build info */
 		err = qca_read_fw_build_info(hdev);
 		if (err < 0)
--- a/drivers/bluetooth/btqca.h
+++ b/drivers/bluetooth/btqca.h
@@ -48,6 +48,8 @@
 
 #define QCA_FW_BUILD_VER_LEN		255
 
+#define MAPLE_NVM_READY_DELAY_MS        1500
+#define MAPLE_POWER_CONTROL_DELAY_MS    50
 
 enum qca_baudrate {
 	QCA_BAUDRATE_115200 	= 0,
@@ -148,6 +150,7 @@ enum qca_btsoc_type {
 	QCA_WCN3991,
 	QCA_QCA6390,
 	QCA_WCN6750,
+	QCA_MAPLE,
 	QCA_WCN6855,
 	QCA_WCN7850,
 };
@@ -161,6 +164,12 @@ int qca_uart_setup(struct hci_dev *hdev,
 int qca_read_soc_version(struct hci_dev *hdev, struct qca_btsoc_version *ver,
 			 enum qca_btsoc_type);
 int qca_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr);
+
+static inline bool qca_is_maple(enum qca_btsoc_type soc_type)
+{
+	return soc_type == QCA_MAPLE;
+}
+
 int qca_send_pre_shutdown_cmd(struct hci_dev *hdev);
 #else
 
@@ -189,6 +198,11 @@ static inline int qca_set_bdaddr(struct
 	return -EOPNOTSUPP;
 }
 
+static inline bool qca_is_maple(enum qca_btsoc_type soc_type)
+{
+	return false;
+}
+
 static inline int qca_send_pre_shutdown_cmd(struct hci_dev *hdev)
 {
 	return -EOPNOTSUPP;
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@ -71,6 +71,10 @@
 #define QCA_CRASHBYTE_PACKET_LEN	1096
 #define QCA_MEMDUMP_BYTE		0xFB
 
+#ifndef IOCTL_IPC_BOOT
+#define IOCTL_IPC_BOOT                  0xBE
+#endif
+
 enum qca_flags {
 	QCA_IBS_DISABLED,
 	QCA_DROP_VENDOR_EVENT,
@@ -1393,6 +1397,9 @@ static unsigned int qca_get_speed(struct
 {
 	unsigned int speed = 0;
 
+	if (qca_is_maple(qca_soc_type(hu)))
+		return 0;
+
 	if (speed_type == QCA_INIT_SPEED) {
 		if (hu->init_speed)
 			speed = hu->init_speed;
@@ -1423,6 +1430,9 @@ static int qca_check_speeds(struct hci_u
 			return -EINVAL;
 		break;
 
+	case QCA_MAPLE:
+		return 0;
+
 	default:
 		if (!qca_get_speed(hu, QCA_INIT_SPEED) ||
 		    !qca_get_speed(hu, QCA_OPER_SPEED))
@@ -1740,6 +1750,21 @@ static int qca_regulator_init(struct hci
 	return 0;
 }
 
+static int qca_maple_power_control(struct hci_uart *hu, bool on)
+{
+	int ret;
+	int power_arg = on ? 1 : 0;
+
+	ret = serdev_device_ioctl(hu->serdev, IOCTL_IPC_BOOT, power_arg);
+	if (ret)
+		bt_dev_err(hu->hdev, "%s: power %s failure: %d\n", __func__,
+			   on ? "ON" : "OFF", ret);
+	else
+		msleep(MAPLE_POWER_CONTROL_DELAY_MS);
+
+	return ret;
+}
+
 static int qca_power_on(struct hci_dev *hdev)
 {
 	struct hci_uart *hu = hci_get_drvdata(hdev);
@@ -1765,6 +1790,10 @@ static int qca_power_on(struct hci_dev *
 		ret = qca_regulator_init(hu);
 		break;
 
+	case QCA_MAPLE:
+		ret = qca_maple_power_control(hu, true);
+		break;
+
 	default:
 		qcadev = serdev_device_get_drvdata(hu->serdev);
 		if (qcadev->bt_en) {
@@ -1811,6 +1840,10 @@ static int qca_setup(struct hci_uart *hu
 		soc_name = "wcn399x";
 		break;
 
+	case QCA_MAPLE:
+		soc_name = "maple";
+		break;
+
 	case QCA_WCN6750:
 		soc_name = "wcn6750";
 		break;
@@ -1898,7 +1931,10 @@ retry:
 	ret = qca_uart_setup(hdev, qca_baudrate, soc_type, ver,
 			firmware_name);
 	if (!ret) {
-		clear_bit(QCA_IBS_DISABLED, &qca->flags);
+		if (qca_is_maple(soc_type))
+			set_bit(QCA_ROM_FW, &qca->flags);
+		else
+			clear_bit(QCA_IBS_DISABLED, &qca->flags);
 		qca_debugfs_init(hdev);
 		hu->hdev->hw_error = qca_hw_error;
 		hu->hdev->cmd_timeout = qca_cmd_timeout;
@@ -2007,6 +2043,11 @@ static const struct qca_device_data qca_
 	.capabilities = QCA_CAP_WIDEBAND_SPEECH | QCA_CAP_VALID_LE_STATES,
 };
 
+static const struct qca_device_data qca_soc_data_maple __maybe_unused = {
+	.soc_type = QCA_MAPLE,
+	.num_vregs = 0,
+};
+
 static const struct qca_device_data qca_soc_data_wcn6750 __maybe_unused = {
 	.soc_type = QCA_WCN6750,
 	.vregs = (struct qca_vreg []) {
@@ -2087,6 +2128,10 @@ static void qca_power_shutdown(struct hc
 		qca_regulator_disable(qcadev);
 		break;
 
+	case QCA_MAPLE:
+		qca_maple_power_control(hu, false);
+		break;
+
 	case QCA_WCN6750:
 	case QCA_WCN6855:
 		gpiod_set_value_cansleep(qcadev->bt_en, 0);
@@ -2282,6 +2327,13 @@ static int qca_serdev_probe(struct serde
 		}
 		break;
 
+	case QCA_MAPLE:
+		dev_info(&serdev->dev, "Maple: power ctrl enabled\n");
+		err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
+		if (err)
+			return err;
+		break;
+
 	default:
 		qcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, "enable",
 					       GPIOD_OUT_LOW);
@@ -2352,6 +2404,10 @@ static void qca_serdev_remove(struct ser
 		}
 		fallthrough;
 
+	case QCA_MAPLE:
+		qca_power_shutdown(&qcadev->serdev_hu);
+		break;
+
 	default:
 		if (qcadev->susclk)
 			clk_disable_unprepare(qcadev->susclk);
@@ -2531,6 +2587,7 @@ static SIMPLE_DEV_PM_OPS(qca_pm_ops, qca
 static const struct of_device_id qca_bluetooth_of_match[] = {
 	{ .compatible = "qcom,qca6174-bt" },
 	{ .compatible = "qcom,qca6390-bt", .data = &qca_soc_data_qca6390},
+	{ .compatible = "qcom,maple-bt", .data = &qca_soc_data_maple},
 	{ .compatible = "qcom,qca9377-bt" },
 	{ .compatible = "qcom,wcn3988-bt", .data = &qca_soc_data_wcn3988},
 	{ .compatible = "qcom,wcn3990-bt", .data = &qca_soc_data_wcn3990},
